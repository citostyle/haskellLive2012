> data Nat = Z | S Nat deriving Show

instance Eq Nat where
	(==) Z Z 			= True
	(==) (S m) Z		= False
	(==) Z (S n)		= False
	(==) (S m) (S n) 	= (m == n)

> plusNat :: Nat -> Nat -> Nat
> plusNat Z b = b
> plusNat (S a) b = S (plusNat a b)

> minusNat :: Nat -> Nat -> Nat
> minusNat (S a) (S b) = minusNat a b
> minusNat a Z = a
> minusNat a (S b) = Z

> timesNat :: Nat -> Nat -> Nat
> timesNat a Z = Z
> timesNat a (S b) = plusNat a (timesNat a b)


> divNat :: Nat -> Nat -> Nat
> divNat a Z = error "Invalid argument"
> divNat Z b = Z
> divNat a b
>	| eqNat a b = (S Z)
>	| grNat a b = plusNat (S Z) (divNat (minusNat a b) b)
>	| otherwise = (Z)


> modNat :: Nat -> Nat -> Nat
> modNat _ Z = error "Invalid argument"
> modNat Z _ = Z
> modNat a b
>	| eqNat a b = (Z)
>	| grNat a b = modNat (minusNat a b) b
>	| otherwise = a


> eqNat :: Nat -> Nat -> Bool
> eqNat Z Z = True
> eqNat (S a) (S b) = eqNat a b
> eqNat _ Z = False
> eqNat Z _ = False


> grNat :: Nat -> Nat -> Bool
> grNat Z Z = False
> grNat (S a) (S b) = grNat a b
> grNat _ Z = True
> grNat Z _ = False


> leNat :: Nat -> Nat -> Bool
> leNat Z Z = False
> leNat (S a) (S b) = leNat a b
> leNat _ Z = False
> leNat Z _ = True


> grEqNat :: Nat -> Nat -> Bool
> grEqNat Z Z = True
> grEqNat (S a) (S b) = grEqNat a b
> grEqNat _ Z = True
> grEqNat Z _ = False


> leEqNat :: Nat -> Nat -> Bool
> leEqNat Z Z = True
> leEqNat (S a) (S b) = leEqNat a b
> leEqNat _ Z = False
> leEqNat Z _ = True




> type NatPair = (Nat,Nat)

> mkCan :: NatPair -> NatPair
> mkCan (a,b)
>	| grEqNat a b = (minusNat a b,Z)
>	| otherwise = (Z,minusNat b a)


> plusNP :: NatPair -> NatPair -> NatPair
> plusNP a b
>	| a `eqNP` (Z,Z) = b
>	| b `eqNP` (Z,Z) = a
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = (plusNat (fst a) (fst b),Z)
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = plusNP (minusNat (fst(a)) (S Z),Z) (Z, minusNat (snd(b)) (S Z))
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = plusNP b a
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = (Z,plusNat (snd a) (snd b))
>	| otherwise = plusNP (mkCan a) (mkCan b)

case 1: a == 0
case 2: b == 0
case 3: a pos && b pos
case 4: a pos && b neg
case 5: a ned && b pos
case 6: a ned && b neg
case 7: NatPair not well formated

> minusNP :: NatPair -> NatPair -> NatPair
> minusNP a b = plusNP a (snd(b),fst(b))



> timesNP :: NatPair -> NatPair -> NatPair
> timesNP (a,Z) (b,Z) = (timesNat a b,Z)
> timesNP (Z,a) (Z,b) = (timesNat a b,Z)
> timesNP (a,Z) (Z,b) = (Z,timesNat a b)
> timesNP (Z,a) (b,Z) = (Z,timesNat a b)
> timesNP a b = timesNP (mkCan a) (mkCan b)


> divNP :: NatPair -> NatPair -> NatPair
> divNP a b
>	| fst(a) `eqNat` Z && snd(a) `eqNat` Z = (Z,Z)
>	| fst(b) `eqNat` Z && snd(b) `eqNat` Z = error "Invalid argument"
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = (Z, plusNat(divNat (snd a) (fst b)) (if modNat (snd a) (fst b) `grNat` Z then (S Z) else (Z))) -- neg pos
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = (divNat (fst a) (fst b),Z)										-- pos pos
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = (Z, divNat (fst a) (snd b))									-- pos neg
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = (plusNat(divNat (snd a) (snd b)) (if modNat (snd a) (snd b) `grNat` Z then (S Z) else (Z)), Z)						-- neg neg
>	| otherwise = divNP (mkCan a) (mkCan b)

case 1: a zero
case 2: b zero
case 3: a neg && b pos
case 4: a pos && b pos
case 5: a pos && b neg
case 6: a neg && b neg
case 7: NatPair not well formated



> modNP :: NatPair -> NatPair -> NatPair
> modNP a b
>	| fst(a) `eqNat` Z && snd(a) `eqNat` Z = (Z,Z)
>	| fst(b) `eqNat` Z && snd(b) `eqNat` Z = error "Invalid argument"
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = (modNat (fst a) (fst b),Z)
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = (modNat (fst a) (snd b), Z)
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = (if modNat (snd a) (fst b) `eqNat` Z then (Z) else minusNat (fst b) (modNat (snd a) (fst b)), Z)
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = (if modNat (snd a) (snd b) `eqNat` Z then (Z) else (minusNat (snd b) (modNat (snd a) (snd b))), Z)
>	| otherwise = modNP (mkCan a) (mkCan b)

case 1: a zero
case 2: b zero
case 3: a pos && b pos
case 4: a pos && b neg
case 5: a neg && b pos
case 6: a neg && b neg
case 7: NatPair not well formated

> eqNP :: NatPair -> NatPair -> Bool
> eqNP (Z,Z) (Z,Z) = True
> eqNP (a,Z) (b,Z) = eqNat a b
> eqNP (Z,a) (Z,b) = eqNat a b
> eqNP (Z,_) (_,Z) = False
> eqNP (_,Z) (Z,_) = False
> eqNP a b = eqNP (mkCan a) (mkCan b)



> grNP :: NatPair -> NatPair -> Bool
> grNP a b
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = grNat (fst a) (fst b)
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = True
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = False
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = grNat (snd b) (snd a)
>	| otherwise = grNP (mkCan a) (mkCan b)

case 1: a pos && b pos [or ((Z,Z),(Z,Z))]
case 2: a pos && b neg
case 3: a neg && b pos
case 4: a neg && b neg
case 5: NatPair not well formated


> leNP :: NatPair -> NatPair -> Bool
> leNP a b
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = leNat (fst a) (fst b)
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = False
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = True
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = leNat (snd b) (snd a)
>	| otherwise = leNP (mkCan a) (mkCan b)


> grEqNP :: NatPair -> NatPair -> Bool
> grEqNP a b
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = grEqNat (fst a) (fst b)
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = True
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = False
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = grEqNat (snd b) (snd a)
>	| otherwise = grEqNP (mkCan a) (mkCan b)


> leEqNP :: NatPair -> NatPair -> Bool
> leEqNP a b
>	| snd(a) `eqNat` Z && snd(b) `eqNat` Z = leEqNat (fst a) (fst b)
>	| snd(a) `eqNat` Z && fst(b) `eqNat` Z = False
>	| fst(a) `eqNat` Z && snd(b) `eqNat` Z = True
>	| fst(a) `eqNat` Z && fst(b) `eqNat` Z = leEqNat (snd b) (snd a)
>	| otherwise = leEqNP (mkCan a) (mkCan b)
